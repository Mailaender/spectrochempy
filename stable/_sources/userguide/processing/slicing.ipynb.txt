{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "67030025",
   "metadata": {},
   "source": [
    "# Slicing NDDatasets\n",
    "\n",
    "This tutorial shows how to handle NDDatasets using python slicing. As prerequisite, the user is\n",
    "expected to have read the [Import Tutorials](../importexport/import.html)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0b174d63",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import spectrochempy as scp"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cd5aae1a",
   "metadata": {},
   "source": [
    "## What is the slicing ?\n",
    "\n",
    "The slicing of a list or an array means taking elements from a given index (or set of indexes) to another index (or set of indexes). Slicing is specified using the colon operator `:` with a `from` and `to` index before and after the first column, and a `step` after the second column. Hence a slice of the object `X` will be set as:\n",
    "\n",
    "`X[from:to:step]`\n",
    "\n",
    "and will extend from the ‘from’ index, ends one item before the ‘to’ index and with an increment of `step`between each index. When not given the default values are respectively 0 (i.e. starts at the 1st index), length in the dimension (stops at the last index), and 1.\n",
    "\n",
    "Let's first illustrate the concept on a 1D example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "31472ffe",
   "metadata": {},
   "outputs": [],
   "source": [
    "X = np.arange(10)  # generates a 1D array of 10 elements from 0 to 9\n",
    "print(X)\n",
    "print(X[2:5])  # selects all elements from 2 to 4\n",
    "print(X[::2])  # selects one out of two elements\n",
    "print(X[:-3])  # a negative index will be counted from the end of the array\n",
    "print(\n",
    "    X[::-2]\n",
    ")  # a negative step will slice backward, starting from 'to', ending at 'from'"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6145e786",
   "metadata": {},
   "source": [
    "The same applies to multidimensional arrays by indicating slices separated by commas:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5f307080",
   "metadata": {},
   "outputs": [],
   "source": [
    "X = np.random.rand(10, 10)  # genarates a 10x10 array filled with random values\n",
    "print(X.shape)\n",
    "print(X[2:5, :].shape)  # slices along the 1st dimension, X[2:5,] is equivalent\n",
    "print(\n",
    "    X[2:5, ::2].shape\n",
    ")  # same slice along 1st dimension and takes one 1 column out of two along the second"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "413510c4",
   "metadata": {},
   "source": [
    "## Slicing of NDDatasets\n",
    "\n",
    "Let's import a group of IR spectra, look at its content and plot it:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9abd3101",
   "metadata": {},
   "outputs": [],
   "source": [
    "X = scp.read_omnic(\"irdata/CO@Mo_Al2O3.SPG\", description=\"CO adsorption, diff spectra\")\n",
    "X.y = (X.y - X[0].y).to(\"minute\")\n",
    "X"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "214574ca",
   "metadata": {},
   "outputs": [],
   "source": [
    "subplot = (\n",
    "    X.plot()\n",
    ")  # assignment avoids the display of the object address (<matplotlib.axes._subplots.AxesSubplot at 0x294076b93c8> or similar)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1f3106af",
   "metadata": {},
   "source": [
    "### Slicing with indexes\n",
    "\n",
    "The classical slicing, using integers, can be used. For instance, along the 1st dimension:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c79ce12b",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(X[:4])  # selects the first four spectra\n",
    "print(X[-3:])  # selects the last three spectra\n",
    "print(X[::2])  # selects one spectrum out of 2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8fbac106",
   "metadata": {},
   "source": [
    "The same can be made along the second dimension, simultanesly or not with the first one. For instance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a81e9d75",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\n",
    "    X[:, ::2]\n",
    ")  # all spectra, one wavenumber out of 2   (note the bug: X[,::2] generates an error)\n",
    "print(\n",
    "    X[0:3, 200:1000:2]\n",
    ")  # 3 first spectra, one wavenumbers out of 2, from index 200 to 1000"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d411e18",
   "metadata": {},
   "source": [
    "Would you easily guess which wavenumber range have been actually selected ?.... probably not because the relationship between the index and the wavenumber is not straightforward as it depends on the the value of the first wavenumber, the wavenumber spacing, and whether the wavenumbers are arranged in ascending or descending order...\n",
    "Here is the answer:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0a900b51",
   "metadata": {},
   "outputs": [],
   "source": [
    "X[\n",
    "    :, 200:1000:2\n",
    "].x  # as the Coord can be sliced, the same is obtained with: X.x[200:1000:2]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "97f3a254",
   "metadata": {},
   "source": [
    "### Slicing with coordinates\n",
    "\n",
    "Now the spectroscopist is generally interested in a particular region of the spectrum, for instance, 2300-1900 cm$^{-1}$. Can you easily guess the indexes that one should use to spectrum this region ? probably not without a calculator...\n",
    "\n",
    "Fortunately, a simple mechanism has been implemented in spectrochempy for this purpose: the use of floats instead of integers will slice the NDDataset at the corresponding coordinates. For instance to select the 2300-1900 cm$^{-1}$ region:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0843688d",
   "metadata": {},
   "outputs": [],
   "source": [
    "subplot = X[:, 2300.0:1900.0:].plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "748f1752",
   "metadata": {},
   "source": [
    "The same mechanism can be used along the first dimension (`y`). For instance, to select and plot the same region and the spectra recorded between 80 and 180 minutes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6587457b",
   "metadata": {},
   "outputs": [],
   "source": [
    "subplot = X[\n",
    "    80.0:180.0, 2300.0:1900.0\n",
    "].plot()  # Note that a decimal point is enough to get a float\n",
    "# a warning is raised if one or several values are beyond the limits"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dcf4a962",
   "metadata": {},
   "source": [
    "Similarly, the spectrum recorded at the time the closest to 60 mins can be selected using a float:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ccc74ff",
   "metadata": {},
   "outputs": [],
   "source": [
    "X[60.0].y  # X[60.] slices the spectrum,  .y returns the corresponding `y` axis."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3bafbd95",
   "metadata": {},
   "source": [
    "--- End of Tutorial ---\n",
    "   (todo: add advanced slicing by array of indexes, array of bool,  )"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "encoding": "# -*- coding: utf-8 -*-",
   "formats": "ipynb,py:percent",
   "notebook_metadata_filter": "all"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
