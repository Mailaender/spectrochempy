{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5e6ba9e1",
   "metadata": {},
   "source": [
    "# Alignment of datasets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "81eede3a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import spectrochempy as scp"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dbe01255",
   "metadata": {},
   "source": [
    "## Example"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9e58b35c",
   "metadata": {},
   "source": [
    "To allow some mathematical operations or dataset processing, it is often necessary that the datasets are aligned,\n",
    "*i.e.,* that they have compatible coordinate for the dimensions.\n",
    "\n",
    "For sake of demonstration, let's take an experimental dataset that we will arbitrary split into four unaligned\n",
    "datasets. Then will realign them and appy some binary mathematical operation such as addition or subtration that\n",
    "required aligned coordinates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c127810c",
   "metadata": {},
   "outputs": [],
   "source": [
    "dataset = scp.NDDataset.read_omnic(\"irdata/nh4y-activation.spg\")\n",
    "dataset.y = dataset.y - dataset.y[0]  # remove offset in the time\n",
    "dataset.y.title = \"time\"\n",
    "prefs = dataset.preferences\n",
    "prefs.reset()\n",
    "prefs.figure.figsize = (7, 3)\n",
    "prefs.figure.dpi = 100\n",
    "_ = dataset.plot_map(colormap=\"viridis\", colorbar=True)\n",
    "print(\"shape:\", dataset.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d0f870f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "nd1 = dataset[0:30, 0:4000]\n",
    "nd2 = dataset[0:30, 2000:5549]\n",
    "nd3 = dataset[10:55, 0:4000]\n",
    "nd4 = dataset[10:55, 2000:5549]\n",
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd1, nd2, nd3, nd4],\n",
    "    colormap=\"viridis\",\n",
    "    nrow=2,\n",
    "    ncol=2,\n",
    "    sharex=True,\n",
    "    sharey=True,\n",
    "    dpi=100,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3b8a9e5f",
   "metadata": {},
   "source": [
    "The four datasets `nd1` to `nd4` have some overlapping in both dimensions. But it we want for example to add `nd2`\n",
    "with `nd4`. This will fail because the dimension are not aligned."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8466b224",
   "metadata": {},
   "outputs": [],
   "source": [
    "try:\n",
    "    nd2 + nd4\n",
    "except Exception as e:\n",
    "    scp.error_(str(e) + \" Cannot add unaligned datasets.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f1cc3aa",
   "metadata": {},
   "source": [
    "Let try to align them, in the `y` dimension (*i.e.* the first) as this the one which differ in size.\n",
    "(NOTE: to find the actual names of the dimensions, just get the `dims` attribute of the datasets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21df03f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "nd2.dims, nd4.dims"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "285fb621",
   "metadata": {},
   "source": [
    "To align we can use different methods, depending on the expected results (missing values in the aligned datasets\n",
    "will be masked)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ef1e8fd7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# `outer` method => union of the coordinates\n",
    "nd2a, nd4a = scp.align(nd2, nd4, dim=\"y\", method=\"outer\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "93095d83",
   "metadata": {},
   "source": [
    "Now we can perform an addition without any problem"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "39f509ef",
   "metadata": {},
   "outputs": [],
   "source": [
    "ndadd = nd2a + nd4a\n",
    "ndadd.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fa6e1564",
   "metadata": {},
   "source": [
    "Let's plot both individual aligned arrays, and their sum. Note, that only the common region appears in the result\n",
    "array, as the mathematical operation are aware of the masks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "10a2c87c",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd2a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "77ce7c8c",
   "metadata": {},
   "source": [
    "Now, assume we want to align in the other dimension, or both"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2d92ac43",
   "metadata": {},
   "outputs": [],
   "source": [
    "try:\n",
    "    nd1 + nd2\n",
    "except Exception as e:\n",
    "    scp.error_(str(e) + \" Cannot add unaligned datasets.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cfabc101",
   "metadata": {},
   "outputs": [],
   "source": [
    "nd1a, nd2a = scp.align(nd1, nd2, dim=\"x\", method=\"outer\")\n",
    "ndadd = nd1a + nd2a\n",
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd1a, nd2a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")\n",
    "ndadd.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "78c74872",
   "metadata": {},
   "source": [
    "## Methods for alignments\n",
    "Method for alignments are:\n",
    "\n",
    "* **outer** which means that a union of the different coordinates is achieved (missing values are masked)\n",
    "* **inner** which means that the intersection of the coordinates is used\n",
    "* **first** which means that the first dataset is used as reference\n",
    "* **last** which means that the last dataset is used as reference\n",
    "* **interpolate** means that interpolation is performed to handle missing points whenever it is possible (Not yet\n",
    "implemented)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de0e85a8",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "### `inner` method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b76993d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# `inner` method => intersection of the coordinates\n",
    "nd2a, nd4a = scp.align(nd2, nd4, dim=\"y\", method=\"inner\")\n",
    "ndadd = nd2a + nd4a\n",
    "ndadd.shape  # note the difference with the outer method above (the shape correspond to the intersection)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f34d186c",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd2a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "31479685",
   "metadata": {},
   "source": [
    "### `first` method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0aa776aa",
   "metadata": {},
   "outputs": [],
   "source": [
    "# `inner` method => align on the first dataset\n",
    "nd2a, nd4a = scp.align(nd2, nd4, dim=\"y\", method=\"first\")\n",
    "ndadd = nd2a + nd4a\n",
    "ndadd.shape  # note the difference with the outer method above"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e86f1f30",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd2a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "618ea1a7",
   "metadata": {},
   "source": [
    "### `last` method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3629c7d1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# `last` method => align on the last dataset\n",
    "nd2a, nd4a = scp.align(nd2, nd4, dim=\"y\", method=\"last\")\n",
    "ndadd = nd2a + nd4a\n",
    "ndadd.shape  # note the difference with the outer method above"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "38f7cb94",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd2a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cee16115",
   "metadata": {},
   "source": [
    "## Alignment along several dimensions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c66a8df9",
   "metadata": {},
   "outputs": [],
   "source": [
    "nd1a, nd4a = scp.align(nd1, nd4, dims=[\"y\", \"x\"])  # by default the outer method is used\n",
    "ndadd = nd1a + nd4a\n",
    "# Comparison of the result array with the original (only the common region is visible, due to the masks)\n",
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd1a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharex=0,\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")\n",
    "nd1a.shape, nd4a.shape, ndadd.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0d4e9243",
   "metadata": {},
   "outputs": [],
   "source": [
    "nd1a, nd4a = scp.align(\n",
    "    nd1, nd4, dims=[\"y\", \"x\"], method=\"inner\"\n",
    ")  # by default the outer method is used\n",
    "ndadd = nd1a + nd4a\n",
    "# Comparison of the result array with the original (only the common region is visible, due to the masks)\n",
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd1a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharex=0,\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6223b530",
   "metadata": {},
   "outputs": [],
   "source": [
    "nd1a, nd4a = scp.align(\n",
    "    nd1, nd4, dims=[\"y\", \"x\"], method=\"first\"\n",
    ")  # by default the outer method is used\n",
    "ndadd = nd1a + nd4a\n",
    "# Comparison of the result array with the original (only the common region is visible, due to the masks)\n",
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd1a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharex=0,\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "873f5367",
   "metadata": {},
   "outputs": [],
   "source": [
    "nd1a, nd4a = scp.align(\n",
    "    nd1, nd4, dims=[\"y\", \"x\"], method=\"last\"\n",
    ")  # by default the outer method is used\n",
    "ndadd = nd1a + nd4a\n",
    "# Comparison of the result array with the original (only the common region is visible, due to the masks)\n",
    "_ = scp.multiplot_map(\n",
    "    datasets=[nd1a, nd4a, ndadd],\n",
    "    colormap=\"viridis\",\n",
    "    sharex=0,\n",
    "    sharey=True,\n",
    "    nrow=1,\n",
    "    ncol=3,\n",
    "    figsize=(8, 3),\n",
    "    dpi=100,\n",
    ")"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "formats": "ipynb,py:percent",
   "notebook_metadata_filter": "all"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.1"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {},
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
