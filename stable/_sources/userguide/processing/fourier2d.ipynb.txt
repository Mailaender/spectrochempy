{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "56d0ee6e",
   "metadata": {},
   "source": [
    "# Two-dimensional (2D) Fourier transformation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2dca0e21",
   "metadata": {},
   "outputs": [],
   "source": [
    "import spectrochempy as scp"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3d9537ef",
   "metadata": {},
   "source": [
    "Additional import to simplify the use of units"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "beda7415",
   "metadata": {},
   "outputs": [],
   "source": [
    "from spectrochempy import ur"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7e4794f5",
   "metadata": {},
   "source": [
    "## Processing of NMR dataset with hypercomplex detection (phase-senitive)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "114c5aef",
   "metadata": {},
   "source": [
    "As a first example, we will process a 2D HMQC spectrum which has been acquired using a phase sensitive detection\n",
    "method : STATES-TPPI encoding.  The STATES (States, Ruben, Haberkorn) produce an hypercomplex dataset which need to\n",
    "be processed in a specific way, that SpectroChemPy handle automatically. TPPI (for Time Proportinal Phase\n",
    "Increment) is also handled."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ecf1d39f",
   "metadata": {},
   "outputs": [],
   "source": [
    "path = scp.preferences.datadir / \"nmrdata\" / \"bruker\" / \"tests\" / \"nmr\" / \"topspin_2d\"\n",
    "ser = scp.read_topspin(path, expno=1)\n",
    "ser"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "496aa656",
   "metadata": {},
   "source": [
    "Change of some plotting preferences"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "785b4152",
   "metadata": {},
   "outputs": [],
   "source": [
    "prefs = ser.preferences\n",
    "prefs.figure.figsize = (7, 3)\n",
    "prefs.contour_start = 0.05"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "63faa856",
   "metadata": {},
   "source": [
    "and now plotting of contours using `plot_map`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "adadc3ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = ser.plot_map()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "50e8771b",
   "metadata": {},
   "source": [
    "### Processing steps\n",
    "\n",
    "* Optional : Apply some broadening by apodization in the time domain.\n",
    "* Optional : DC correction in the time domain.\n",
    "* Optional : Zero-filling.\n",
    "* Fourier transform in the F2 (x) dimension.\n",
    "* Phase  the first transformed dimension in the frequency domain.\n",
    "* Optional: Apply some apodization in the time domain for the F1 (y) dimension.\n",
    "* Optional: DC Correction in F1.\n",
    "* Optional: Zero-filling.\n",
    "* Fourier transform the second dimension F1.\n",
    "* Phase correct the second transformed dimension in the frequency domain.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "86cf60a7",
   "metadata": {},
   "source": [
    "### Apodization, DC correction, Zero-filling"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6c964b98",
   "metadata": {},
   "source": [
    "For this step we can first extract and Fourier transformation of the first row (row index:0)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "79d2d245",
   "metadata": {},
   "outputs": [],
   "source": [
    "row0 = ser[0]\n",
    "_ = row0.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f4fc9153",
   "metadata": {},
   "source": [
    "We can zoom to have a better look at the echo (with the imaginary component)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7e8ff6b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = row0.plot(show_complex=True, xlim=(0, 10000))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0cc6859e",
   "metadata": {},
   "source": [
    "Now we will perform the processing of the first row and adjust the parameters for apodization, zero-filling, etc..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e31ec50a",
   "metadata": {},
   "outputs": [],
   "source": [
    "row0 = ser[0]\n",
    "\n",
    "row0.dc(inplace=True)  # DC corrrection\n",
    "row0.zf_size(\n",
    "    size=2048, inplace=True\n",
    ")  # zero-filling (size parameter can be approximate as the FFT will\n",
    "# anyway complete the zero-filling to next power of 2.)\n",
    "shifted = row0.coordmax()  # find the top of the echo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ef5fd33b",
   "metadata": {},
   "outputs": [],
   "source": [
    "newrow, apod = row0.em(lb=20 * ur.Hz, shifted=shifted, retapod=True)\n",
    "# retapod: return the apod array along with the apodized dataset\n",
    "newrow.plot()\n",
    "apod.plot(clear=False, xlim=(0, 20000), c=\"red\")\n",
    "\n",
    "f0 = newrow.fft()  # fourier transform\n",
    "_ = f0.plot(show_complex=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5bcfbffa",
   "metadata": {},
   "source": [
    "Once we have found correct parameters for correcting the first row, we can apply them for the whole 2D dataset in\n",
    "the F2 dimension (the default dimension, so no need to specify this in the following methods)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ade18cb6",
   "metadata": {},
   "outputs": [],
   "source": [
    "sert = ser.dc()  # DC correction\n",
    "sert.zf_size(size=2048, inplace=True)  # zero-filling\n",
    "sert.em(\n",
    "    lb=20 * ur.Hz, shifted=shifted, inplace=True\n",
    ")  # shifted was set in the previous step\n",
    "_ = sert.plot_map()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "761123c3",
   "metadata": {},
   "source": [
    "Transform in F2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a452dc36",
   "metadata": {},
   "outputs": [],
   "source": [
    "spec = sert.fft()\n",
    "_ = spec.plot_map()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40a3bca5",
   "metadata": {},
   "source": [
    "Now we can process the F1 dimension ('y')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f6f690e2",
   "metadata": {},
   "outputs": [],
   "source": [
    "spect = spec.zf_size(size=512, dim=\"y\")\n",
    "spect.em(lb=10 * ur.Hz, inplace=True, dim=\"y\")\n",
    "s = spect.fft(dim=\"y\")\n",
    "prefs.contour_start = 0.12\n",
    "_ = s.plot_map()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d92d4da0",
   "metadata": {},
   "source": [
    "Here is an expansion:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "815d40db",
   "metadata": {},
   "outputs": [],
   "source": [
    "spk = s.pk(phc0=0, dim=\"y\")\n",
    "_ = spk.plot_map(xlim=(50, 0), ylim=(-40, -15))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "51be4aa3",
   "metadata": {},
   "source": [
    "## Processing of an Echo-AntiEcho encoded dataset"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "96e9003d",
   "metadata": {},
   "source": [
    "In this second example, we will process a HSQC spectrum of Cyclosporin wich has been acquired using a Rance-Kay\n",
    "quadrature scheme, also known as Echo-Antiecho. (The original data is extracted from the examples of the Bruker\n",
    "Topspin software)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f4462374",
   "metadata": {},
   "outputs": [],
   "source": [
    "path = scp.preferences.datadir / \"nmrdata\" / \"bruker\" / \"tests\" / \"nmr\" / \"exam2d_HC\"\n",
    "ser = scp.read_topspin(path)\n",
    "prefs = ser.preferences\n",
    "prefs.figure.figsize = (7, 3)\n",
    "ser.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6c8fa885",
   "metadata": {},
   "outputs": [],
   "source": [
    "sert = ser.dc()\n",
    "sert.sp(ssb=2, inplace=True)  # Sine apodization\n",
    "s2 = sert.fft(1024)\n",
    "s2.pk(phc0=-90, inplace=True)  # phasing\n",
    "_ = s2[0].plot()\n",
    "ex = (3.5, 2.5)\n",
    "_ = s2[0].plot(xlim=ex)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4ec54f12",
   "metadata": {},
   "outputs": [],
   "source": [
    "s2.sp(ssb=2, dim=\"y\", inplace=True)\n",
    "# Sine apodization in the y dimension"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d6e51b91",
   "metadata": {},
   "outputs": [],
   "source": [
    "ey = (20, 45)\n",
    "prefs.contour_start = 0.07\n",
    "s = s2.fft(256, dim=\"y\")\n",
    "s = s.pk(phc0=-40, dim=\"y\")\n",
    "s = s.pk(phc0=-5, rel=True)\n",
    "_ = s.plot_map(xlim=ex, ylim=ey)\n",
    "_ = s.plot_map()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ea698d56",
   "metadata": {},
   "source": [
    "## Processing a QF encoded file"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b21df818",
   "metadata": {},
   "outputs": [],
   "source": [
    "path = scp.preferences.datadir / \"nmrdata\" / \"bruker\" / \"tests\" / \"nmr\" / \"exam2d_HH\"\n",
    "ser = scp.read_topspin(path)\n",
    "prefs = ser.preferences\n",
    "ser.plot_map()\n",
    "ser.dtype"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f6d0673",
   "metadata": {},
   "outputs": [],
   "source": [
    "sert = ser.dc()\n",
    "sert.sp(ssb=2, inplace=True)  # Sine apodization\n",
    "s2 = sert.fft(1024)\n",
    "s3 = s2.pk(phc0=-140, phc1=95)\n",
    "_ = s3[0].plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "41112392",
   "metadata": {},
   "outputs": [],
   "source": [
    "s3.sp(ssb=0, dim=\"y\", inplace=True)\n",
    "# Sine apodization in the y dimension"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9bea669a",
   "metadata": {},
   "outputs": [],
   "source": [
    "ey = (20, 45)\n",
    "s = s3.fft(256, dim=\"y\")\n",
    "sa = s.abs()\n",
    "\n",
    "prefs.contour_start = 0.005\n",
    "prefs.show_projections = True\n",
    "prefs.figure.figsize = (7, 7)\n",
    "_ = sa.plot_map()"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "title,-all",
   "encoding": "# -*- coding: utf-8 -*-",
   "formats": "ipynb,py:percent",
   "notebook_metadata_filter": "all"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.1"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {},
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
