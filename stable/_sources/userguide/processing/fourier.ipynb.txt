{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ff8901f5",
   "metadata": {},
   "source": [
    "# One-dimensional (1D) Fourier transformation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5be94883",
   "metadata": {},
   "source": [
    "In this notebook, we are going to transform time-domain data into 1D or 2D spectra using SpectroChemPy\n",
    "processing tools"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0747789a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import spectrochempy as scp"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ef2debf",
   "metadata": {},
   "source": [
    "## FFT of 1D NMR spectra"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "003f0814",
   "metadata": {},
   "source": [
    "First we open read some time domain data. Here is a NMD free induction decay (FID):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "48b36c7b",
   "metadata": {},
   "outputs": [],
   "source": [
    "path = scp.preferences.datadir / \"nmrdata\" / \"bruker\" / \"tests\" / \"nmr\" / \"topspin_1d\"\n",
    "fid = scp.read_topspin(path)\n",
    "fid"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d3d614b2",
   "metadata": {},
   "source": [
    "The type of the data is complex:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "874e6f2a",
   "metadata": {},
   "outputs": [],
   "source": [
    "fid.dtype"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7663efe5",
   "metadata": {},
   "source": [
    "We can represent both real and imaginary parts on the same plot using the `show_complex` parameter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e3daceb6",
   "metadata": {},
   "outputs": [],
   "source": [
    "prefs = fid.preferences\n",
    "prefs.figure.figsize = (6, 3)\n",
    "_ = fid.plot(show_complex=True, xlim=(0, 15000))\n",
    "print(\"td = \", fid.size)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fe6df7d7",
   "metadata": {},
   "source": [
    "Now we perform a Fast Fourier Fransform (FFT):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "731b3eb5",
   "metadata": {},
   "outputs": [],
   "source": [
    "spec = scp.fft(fid)\n",
    "_ = spec.plot(xlim=(100, -100))\n",
    "print(\"si = \", spec.size)\n",
    "spec"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83d92b46",
   "metadata": {},
   "source": [
    "**Alternative notation**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "579a1d24",
   "metadata": {},
   "outputs": [],
   "source": [
    "k = 1024\n",
    "spec = fid.fft(size=32 * k)\n",
    "_ = spec.plot(xlim=(100, -100))\n",
    "print(\"si = \", spec.size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c266aee0",
   "metadata": {},
   "outputs": [],
   "source": [
    "newfid = spec.ifft()\n",
    "# x coordinateis in second (base units) so lets transform it\n",
    "_ = newfid.plot(show_complex=True, xlim=(0, 15000))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cd0e3a42",
   "metadata": {},
   "source": [
    "Let's compare fid and newfid. There differs as a rephasing has been automatically applied after the first FFT (with\n",
    "the parameters found in the original fid metadata: PHC0 and PHC1).\n",
    "\n",
    "First point in the time domain of the real part is at the maximum."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "582beecc",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = newfid.real.plot(c=\"r\", label=\"fft + ifft\")\n",
    "ax = fid.real.plot(clear=False, xlim=(0, 5000), ls=\"--\", label=\"original real part\")\n",
    "_ = ax.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "09ebe115",
   "metadata": {},
   "source": [
    "First point in the time domain of the imaginary part is at the minimum."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "db3e0a49",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = fid.imag.plot(ls=\"--\", label=\"original imaginary part\")\n",
    "ax = newfid.imag.plot(clear=False, xlim=(0, 5000), c=\"r\", label=\"fft + ifft\")\n",
    "_ = ax.legend(loc=\"lower right\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c8e0df63",
   "metadata": {},
   "source": [
    "## Preprocessing\n",
    "\n",
    "### Line broadening\n",
    "Often before applying a FFT, some exponential multiplication `em`or other broadening filters such as `gm` or `sp`\n",
    "are applied.\n",
    "See the dedicated [apodization tutorial](apodization.ipynb)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f979a76f",
   "metadata": {},
   "outputs": [],
   "source": [
    "fid2 = fid.em(lb=\"50. Hz\")\n",
    "spec2 = fid2.fft()\n",
    "_ = spec2.plot()\n",
    "_ = spec.plot(\n",
    "    clear=False, xlim=(10, -5), c=\"r\"\n",
    ")  # superpose the unbroadened spectrum in red and show expansion."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6de4b6d8",
   "metadata": {},
   "source": [
    "### Zero-filling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "24005d52",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"td = \", fid.size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c5ea2f30",
   "metadata": {},
   "outputs": [],
   "source": [
    "td = 64 * 1024  # size: 64 K\n",
    "fid3 = fid.zf_size(size=td)\n",
    "print(\"new td = \", fid3.x.size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5aee39d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "spec3 = fid3.fft()\n",
    "_ = spec3.plot(xlim=(100, -100))\n",
    "print(\"si = \", spec3.size)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fdaf0c61",
   "metadata": {},
   "source": [
    "### Time domain baseline correction\n",
    "See the dedicated [Time domain baseline correction tutorial](td_baseline.ipynb)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "75baa978",
   "metadata": {},
   "source": [
    "### Magnitude calculation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a69373b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "ms = spec.mc()\n",
    "_ = ms.plot(xlim=(10, -10))\n",
    "_ = spec.plot(clear=False, xlim=(10, -10), c=\"r\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5b3878e8",
   "metadata": {},
   "source": [
    "### Power spectrum"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a74719d1",
   "metadata": {},
   "outputs": [],
   "source": [
    "mp = spec.ps()\n",
    "_ = (mp / mp.max()).plot()\n",
    "_ = (spec / spec.max()).plot(\n",
    "    clear=False, xlim=(10, -10), c=\"r\"\n",
    ")  # Here we have normalized the spectra at their max value."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5500a01e",
   "metadata": {},
   "source": [
    "# Real Fourier transform"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5645fdf1",
   "metadata": {},
   "source": [
    "In some case, it might be interesting to perform real Fourier transform . For instance, as a demontration,\n",
    "we will independently transform real and imaginary part of the previous fid, and recombine them to obtain the same\n",
    "result as when performing complex Fourier transform on the complex dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c42899b",
   "metadata": {},
   "outputs": [],
   "source": [
    "lim = (-20, 20)\n",
    "_ = spec3.plot(xlim=lim)\n",
    "_ = spec3.imag.plot(xlim=lim)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f326bc7",
   "metadata": {},
   "outputs": [],
   "source": [
    "Re = fid3.real.astype(\"complex64\")\n",
    "fR = Re.fft()\n",
    "_ = fR.plot(xlim=lim, show_complex=True)\n",
    "Im = fid3.imag.astype(\"complex64\")\n",
    "fI = Im.fft()\n",
    "_ = fI.plot(xlim=lim, show_complex=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "becc3ea6",
   "metadata": {},
   "source": [
    "Recombinaison:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b6a86849",
   "metadata": {},
   "outputs": [],
   "source": [
    "_ = (fR - fI.imag).plot(xlim=lim)\n",
    "_ = (fR.imag + fI).plot(xlim=lim)"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "title,-all",
   "encoding": "# -*- coding: utf-8 -*-",
   "formats": "ipynb,py:percent",
   "notebook_metadata_filter": "all"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.1"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {},
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
